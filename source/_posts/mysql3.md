---
title: MySQL入门3——关系型数据库表设计原则与范式设计
date: 2024-04-28 01:16:59
categories:
- MySQL
tags:
- DataBase
- MySQL
---

<meta name="referrer" content="no-referrer" />

<!-- toc -->

## 3.1 关系型数据库表设计原则

做一个项目前，要对项目需求进行可行性项目澄清，分析完成再进行设计。

表设计类似OOP设计，要考虑对象之间关系，是组合还是继承。每个表代表一个实体，表与表之间的关系及实体与实体之间的关系。

**实体与实体之间的关系：**一对一、一对多、多对多。

### 3.1.1 一对一

两张表：

**用户 User**				**父表**

| uid  | name  | age  | sex  |
| ---- | ----- | ---- | ---- |
| 1000 | zhang | 20   | M    |
| 1020 | liu   | 21   | W    |
| 2010 | wang  | 22   | M    |

**身份信息 Info**				**子表**

| uid  | cardid | addrinfo |
| ---- | ------ | -------- |
| 1020 | 112233 | aaa      |
| 1000 | 556677 | ccc      |
| 2010 | 334455 | bbb      |

在子表中增加一列**外键**，关联了父表的主键（列名起的可以不一样，最好是一样）

查询王同学的身份信息：

```
select * from Info where uid=2010;
```



### 3.1.2 一对多

一对多与多对多才是现实开发关系中遇到最多的关系。

实例：设计一个电商系统，有三个实体：用户User、商品Product和订单Order

用户 & 商品：没有关系

用户 & 订单：一对多关系   ——> 子表增加一列关联父表的主键

商品 & 订单：多对多关系   ——> 增加一个中间表



**User：**

| uid  | name  | age  | sex  |
| ---- | ----- | ---- | ---- |
| 1000 | zhang | 20   | M    |
| 1020 | liu   | 21   | W    |
| 2010 | wang  | 22   | M    |

**Product：**

| pid  | pname  | price  | amount |
| ---- | ------ | ------ | ------ |
| 1    | 手机   | 600.0  | 100    |
| 2    | 笔记本 | 2000.0 | 50     |
| 3    | 电池   | 10.0   | 200    |

**Order:**

| orderid | uid  | pid  | number | money  | totalprice | addinfo |
| ------- | ---- | ---- | ------ | ------ | ---------- | ------- |
| O1000   | 1000 | 1    | 1      | 600.0  | 4640.0     | 海淀区  |
| O1000   | 1000 | 2    | 2      | 4000.0 | 4640.0     | 海淀区  |
| O1000   | 1000 | 3    | 4      | 40.0   | 4640.0     | 海淀区  |
| O2000   | 2010 | 2    | 1      | 2000.0 | 2000.0     | 平谷区  |

User与Order是**一对多**的关系

在一张表中增加一列（uid），逻辑关系上对应了父表的主键（类型相同，字段名最好一样）



### 3.1.3 多对多

在Product和Order之间存在**多对多**关系

同一个订单有多少件商品，商品表中就有多少条记录，如此订单表中存储数据过于冗余（totalprice 和addinfo是冗余信息）。当订单增减商品，总价修改时，订单表中会出现大批量的修改。

为了避免数据冗余，订单表简化为

| orderid | uid  | totalprice | addrinfo |
| ------- | ---- | ---------- | -------- |
| O1000   | 1000 | 4640.0     | 海淀区   |
| O2000   | 2010 | 2000.0     | 平谷区   |



增加中间表 **订单内容 OderList**

| orderid | pid  | number | money  |
| ------- | ---- | ------ | ------ |
| O1000   | 1    | 1      | 600.0  |
| O1000   | 2    | 2      | 4000.0 |
| O1000   | 3    | 4      | 40.0   |
| O2000   | 2    | 1      | 2000.0 |

看出多对多关系

商品表中`pid`是主键，Order表中`orderid`是主键（uid不能做主键，他增加一列表示与用户表之间的关联关系）

orderid相同的，pid不可能相同；pid相同的，orderid不可能相同，两个字段共同创建联合索引，加速查找。



**数据冗余造成的后果：**

1.性能降低

2.数据不一致



## 3.2 关系型数据库的范式设计

应用数据库范式可以带来许多好处，但是最重要的好处归结为三点:

1、**减少数据冗余**（主要的好处，其他好处都是由此而附带的）
2、消除异常（插入异常、更新异常、删除异常）
3、让数据组织的更加和谐

但是数据库范式绝对不是越高越好，范式越高，意味着表越多，多表联合询的机率就越大，SQL的效率就变低。

### 3.2.1 第一范式（1NF）

> **每一列保持原子特性**

列都是基本数据项，不能够再进行分割，否则设计成一对多的实体关系。例如表中的地址字段，可以再细分为省，市，区等不可再分割（即**原子**特性）的字段，如下：

<img src="https://gitee.com/tosfk/blog-pic/raw/master/202404280009114.png" alt="image-20240428000929055" style="zoom:50%;" />

上图的表就是把地址字段分成更详细的city、country、street三个字段，注意，**不符合第一范式不能称作关系型数据库**。

如果要查EmployeeID为1某个人的地址信息

```
select * from Employeeaddress where addressID in (select AddressID from noNF where EmployeeID=1);
```

先从noNF表中根据人的ID查到地址的ID，再从Employeeaddress表中查询到具体信息

（带in的子查询效率较低，实际中一般使用连接查询）



### 3.2.2 第二范式（2NF）

> **属性完全依赖于（所有）主键——主要针对联合主键**

非主属性完全依赖于主关键字，如果不是完全依赖主键，应该拆分成新的实体，设计成一对多的实体关系。

**例如：**选课关系表为SelectCourse(学号,姓名,年龄,课程名称,成绩,学分)，(学号，课程名称) 是**联合主键**（多个字段共同构成主键），但是学分字段只和课程名称有关，和学号无关，相当于只依赖联合主键的其中一个字段而不是依赖联合主键中的所有列，**存在冗余**，不符合第二范式。

学生和课程名称之间也构成**多对多**关系，需要添加中间表

| 学号 | 姓名 | 年龄 | 课程id | 成绩 | 学分 |
| ---- | ---- | ---- | ------ | ---- | ---- |

分成学生表

| 学号 | 姓名 | 年龄 |
| ---- | ---- | ---- |

和课程表

| 课程id | 成绩 | 学分 |
| ------ | ---- | ---- |

添加**中间表**：选课关系/情况

| 学号 | 课程id | 成绩 |
| ---- | ------ | ---- |

完美



在上图中，EmployeeID和departmentName作为联合主键，但job/jobDescription只和部门名称有关系，而与具体的人名无关系；skill只和人有关系，而与部门无关系。故设计不遵循范式二，需要拆分联合主键，如下图

<img src="https://gitee.com/tosfk/blog-pic/raw/master/202404280039771.png" alt="image-20240428003926709" style="zoom: 67%;" />



### 3.2.3 第三范式（3NF）

>  **属性不依赖于其它非主属性**

要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。

**示例：**学生关系表为student（**学号**，姓名，年龄，所在学院，学院地点，学院电话），学号是主键，但是学院电话只依赖于所在学院，并不依赖于主键学号，因此该设计不符合第三范式，应该把学院专门设计成一张表，学生表和学院表，两个是一对多的关系。

<img src="https://gitee.com/tosfk/blog-pic/raw/master/202404280050111.png" alt="image-20240428005019045" style="zoom:67%;" />

注意：一般关系型数据库满足第三范式就可以了。

多表查询速度肯定慢于单表查询，所以有时要灵活运用，故意设计存在冗余字段，以加速查询。



### 3.2.4 BC范式（BCNF）

> **每个表中只有一个候选键**

简单的说，BC范式是在第三范式的基础上的一种特殊情况，即每个表中只有一个**候选键（在一个数据库中每行的值都不相同，则可称为候选键）**，在上面第三范式的noNF表（上面图3）中可以看出，每一个员工的email都是唯一的（不可能两个人用同一个email），则此表不符合BC范式，对其进行BC范式化后的关系图为：

<img src="https://gitee.com/tosfk/blog-pic/raw/master/202404280059115.png" alt="image-20240428005949041" style="zoom: 50%;" />

可以不用遵守



### 3.2.5 第四范式（4NF）

> **消除表中的多值依赖**

简单来说，第四范式就是要消除表中的多值依赖，也就是说可以**减少维护数据一致性的工作**。

比如图4中的noNF表中的skill技能这个字段，有的人是"java，mysql"，有的人描述的是"Java，MySQL"，这样数据就不一致了，解决办法就是将多值属性放入一个新表，所以满足第四范式的关系图如下:

<img src="https://gitee.com/tosfk/blog-pic/raw/master/202404280121664.png" alt="image-20240428005949041" style="zoom: 50%;" />





从上面对于数据库范式进行分解的过程中不难看出，应用的范式越高，表越多。表多会带来很多问题：

**1、查询时需要连接多个表，增加了SQL查询的复杂度**

**2、查询时需要连接多个表，降低了数据库查询性能**

因此，并不是应用的范式越高越好，视实际情况而定，**第三范式已经很大程度上减少了数据冗余，并且基本预防了数据插入异常、更新异常和删除异常了。**

